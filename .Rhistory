import pandas
import numpy
import plotly.express
import statsmodels.api
import statsmodels.formula.api
import patsy.contrasts
group = numpy.repeat(["A", "B", "C", "D"], repeats = 25)
group
mean = (3, 4, 4, 3)
sigma = (1.5, 1.5, 1.5, 1.5)
n = (25, 25, 25, 25)
# lists, library_name.function_name notation
group = numpy.repeat(["A", "B", "C", "D"], repeats = 25)
# tuples
mean = (3, 4, 4, 3)
sigma = (1.5, 1.5, 1.5, 1.5)
n = (25, 25, 25, 25)
# tuples
mean = (3, 4, 4, 3)
sigma = (1.5, 1.5, 1.5, 1.5)
n = (25, 25, 25, 25)
# iterate numpy.random.normal through 4 values for mean, sigma, and n, and then concatenate result into 1 array
x = numpy.concatenate([numpy.random.normal(mean, sigma, n) for mean, sigma, n in zip(mean, sigma, n)])
# y is corrletaed r = 0.75 with x, add random noise
y = x * 0.75 + numpy.random.normal(loc = 0.00, scale = 1.00, size = 100)
for  mean, sigma, n in zip(mean, sigma, n):
numpy.random.normal(mean, sigma, n)
for  mean, sigma, n in zip(mean, sigma, n)
numpy.random.normal(mean, sigma, n)
for  mean, sigma, n in zip(mean, sigma, n):
numpy.random.normal(mean, sigma, n)
numpy.random.normal(mean, sigma, n)]
zip(mean, sigma, n)
# tuples
mean = (3, 4, 4, 3)
sigma = (1.5, 1.5, 1.5, 1.5)
n = (25, 25, 25, 25)
numpy.random.normal(mean, sigma, n) for mean, sigma, n in zip(mean, sigma, n)
[numpy.random.normal(mean, sigma, n) for mean, sigma, n in zip(mean, sigma, n)]
numpy.random.normal(mean, sigma, n)]
[numpy.random.normal(mean, sigma, n)]
mean
sigma
n
for mean, sigma, n in zip(mean, sigma, n):
numpy.random.normal(mean, sigma, n)
zip(mean, sigma, n)
for mean, sigma, n in zip(mean, sigma, n)
for mean, sigma, n in zip(mean, sigma, n):
numpy.random.normal(mean, sigma, n)
for mean, sigma, n in zip(mean, sigma, n):
numpy.random.normal(mean, sigma, n)
numpy.random.normal(mean, sigma, n)
numpy.random.normal(mean, sigma, n)
for mean, sigma, n in zip(mean, sigma, n):
numpy.random.normal(mean, sigma, n)
for i in 0:5:
print(i)
for i in 0:5:
print(i)
for i in 0:5:
print(i)
0:5
[0:5]
for x in [0, 1, 2, 3, 4, 5]: print(i)
for x in [0, 1, 2, 3, 4, 5]: print(i)
for x in [0, 1, 2, 3, 4, 5]:
print(i)
[0, 1, 2, 3, 4, 5]
fruits = ["apple", "banana", "cherry"]
for x in fruits:
print(x)
fruits = (1, 2, 3, 4, 5)
for x in fruits:
print(x)
for mean, sigma, n in zip(mean, sigma, n):
numpy.random.normal(mean, sigma, n)
for mean in (3, 4, 4, 5):
numpy.random.normal(loc = mean, scale = 1.5, size = 25)
x = for mean in (3, 4, 4, 5):
numpy.random.normal(loc = mean, scale = 1.5, size = 25)
x * 0.75 + numpy.random.normal(loc = 0.00, scale = 1.00, size = 100)
for mean, sigma, n in zip(mean, sigma, n:
numpy.random.normal(loc = mean, scale = sigma, size = n)
x = for mean, sigma, n in zip(mean, sigma, n:
numpy.random.normal(loc = mean, scale = sigma, size = n)
x = for mean, sigma, n in zip(mean, sigma, n):
numpy.random.normal(loc = mean, scale = sigma, size = n)
x = for mean, sigma, n in zip(mean, sigma, n): numpy.random.normal(loc = mean, scale = sigma, size = n)
x = for (mean, sigma, n) in zip(mean, sigma, n):
numpy.random.normal(loc = mean, scale = sigma, size = n)
(mean, sigma, n)
for mu, s, i in zip(mean, sigma, n):
numpy.random.normal(loc = mu, scale = s, size = i)
for mu, s, i in zip(mean, sigma, n):
numpy.random.normal(loc = mu, scale = s, size = i)
for (mu, s, i) in zip(mean, sigma, n):
numpy.random.normal(loc = mu, scale = s, size = i)
numpy.random.normal(loc = mu, scale = s, size = i)
for mu, s, i in zip(mean, sigma, n):
numpy.random.normal(loc = mu, scale = s, size = i)
x = for mu, s, i in zip(mean, sigma, n):
numpy.random.normal(loc = mu, scale = s, size = i)
numpy.random.normal(loc = mu, scale = s, size = i)
x = for mu, s, i in zip(mean, sigma, n):
numpy.random.normal(loc = mu, scale = s, size = i)
x = numpy.concatenate([numpy.random.normal(mean, sigma, n) for mean, sigma, n in zip(mean, sigma, n)])
x = numpy.concatenate([numpy.random.normal(mean, sigma, n) for mean, sigma, n in zip(mean, sigma, n)])
# iterate numpy.random.normal through 4 values for mean, sigma, and n, and then concatenate result into 1 array
# for comes after function
x = numpy.concatenate([numpy.random.normal(mean, sigma, n) for mean, sigma, n in zip(mean, sigma, n)])
# tuples
mean = (3, 4, 4, 3)
sigma = (1.5, 1.5, 1.5, 1.5)
n = (25, 25, 25, 25)
# iterate numpy.random.normal through 4 values for mean, sigma, and n, and then concatenate result into 1 array
# for comes after function
x = numpy.concatenate([numpy.random.normal(mean, sigma, n) for mean, sigma, n in zip(mean, sigma, n)])
for (a, b, c) in zip(mean, sigma, n):
numpy.random.normal(a, b, c)
x = for (mean, sigma, n) in zip(mean, sigma, n):
numpy.random.normal(mean, sigma, n)
# tuples
mean = (3, 4, 4, 3)
sigma = (1.5, 1.5, 1.5, 1.5)
n = (25, 25, 25, 25)
x = for (m, s, i) in zip(mean, sigma, n):
numpy.random.normal(loc = m, scale = s, size = i)
# tuples
mean = (3, 4, 4, 3)
sigma = (1.5, 1.5, 1.5, 1.5)
n = (25, 25, 25, 25)
# iterate numpy.random.normal through 4 values for mean, sigma, and n, and then concatenate result into 1 array
# for comes after function
x = for (m, s, i) in zip(mean, sigma, n):
numpy.random.normal(loc = m, scale = s, size = i)
for (a, b, c) in zip(mean, sigma, n):
...       numpy.random.normal(a, b, c)
# tuples
mean = (3, 4, 4, 3)
sigma = (1.5, 1.5, 1.5, 1.5)
n = (25, 25, 25, 25)
for (a, b, c) in zip(mean, sigma, n):
numpy.random.normal(a, b, c)
x = for (m, s, i) in zip(mean, sigma, n):
numpy.random.normal(m, s, i)
# tuples
mean = (3, 4, 4, 3)
sigma = (1.5, 1.5, 1.5, 1.5)
n = (25, 25, 25, 25)
# iterate numpy.random.normal through 4 values for mean, sigma, and n, and then concatenate result into 1 array
# for comes after function
x = for (a, b, c) in zip(mean, sigma, n):
numpy.random.normal(a, b, c)
for (a, b, c) in zip(mean, sigma, n):
numpy.random.normal(a, b, c)
x = for (a, b, c) in zip(mean, sigma, n):
numpy.random.normal(a, b, c)
for (a, b, c) in zip(mean, sigma, n):
numpy.random.normal(a, b, c)
x = for (a, b, c) in zip(mean, sigma, n):
numpy.random.normal(a, b, c)
x = [for (a, b, c) in zip(mean, sigma, n):
numpy.random.normal(a, b, c)]
x = for (a, b, c) in zip(mean, sigma, n): numpy.random.normal(a, b, c)
for (a, b, c) in zip(mean, sigma, n): numpy.random.normal(a, b, c)
x = [for (a, b, c) in zip(mean, sigma, n): numpy.random.normal(a, b, c)]
# tuples
mean = (3, 4, 4, 3)
sigma = (1.5, 1.5, 1.5, 1.5)
n = (25, 25, 25, 25)
# iterate numpy.random.normal through 4 values for mean, sigma, and n, and then concatenate result into 1 array
# for comes after function
x = []
for (a, b, c) in zip(mean, sigma, n): x.append.numpy.random.normal(a, b, c)
# iterate numpy.random.normal through 4 values for mean, sigma, and n, and then concatenate result into 1 array
# for comes after function
x = []
for (a, b, c) in zip(mean, sigma, n): x.append(numpy.random.normal(a, b, c))
x
# y is corrletaed r = 0.75 with x, add random noise
y = x * 0.75 + numpy.random.normal(loc = 0.00, scale = 1.00, size = 100)
# iterate numpy.random.normal through 4 values for mean, sigma, and n, and then concatenate result into 1 array
# for comes after function
x = ()
for (a, b, c) in zip(mean, sigma, n): x.append(numpy.random.normal(a, b, c))
# iterate numpy.random.normal through 4 values for mean, sigma, and n, and then concatenate result into 1 array
# for comes after function
x = []
for (a, b, c) in zip(mean, sigma, n): x.append(numpy.random.normal(a, b, c))
numpy.hstack(x)
# iterate numpy.random.normal through 4 values for mean, sigma, and n, and then concatenate result into 1 array
# for comes after function
x = []
for (a, b, c) in zip(mean, sigma, n): x.append(numpy.random.normal(a, b, c))
x = numpy.hstack(x)
# y is corrletaed r = 0.75 with x, add random noise
y = x * 0.75 + numpy.random.normal(loc = 0.00, scale = 1.00, size = 100)
# Empty list
x = []
# Append list with random normal variables
for (a, b, c) in zip(mean, sigma, n):
x.append(numpy.random.normal(a, b, c))
#
x = numpy.concatenate(x)
# y is corrletaed r = 0.75 with x, add random noise
y = x * 0.75 + numpy.random.normal(loc = 0.00, scale = 1.00, size = 100)
x = []
# Append list with random normal variables
for (a, b, c) in zip(mean, sigma, n):
x.append(numpy.random.normal(a, b, c))
x
# y is corrletaed r = 0.75 with x, add random noise
y = x * 0.75 + numpy.random.normal(loc = 0.00, scale = 1.00, size = 100)
# Empty list
x = []
# Append list with random normal variables
for (a, b, c) in zip(mean, sigma, n):
x.append(numpy.random.normal(a, b, c))
# Join results
x = numpy.concatenate(x)
# y is corrletaed r = 0.75 with x, add random noise
y = x * 0.75 + numpy.random.normal(loc = 0.00, scale = 1.00, size = 100)
# curly brackets, colons
data1 = pandas.DataFrame({"y": y, "x": x, "group": group})
# Chunk 1
# install.packages("reticulate")
library(reticulate)
# Chunk 2
# py_install("pandas")
# py_install("numpy")
# py_install("plotly")
# py_install("statsmodels")
# py_install("patsy")
# Chunk 3
import pandas
import numpy
import plotly.express
import statsmodels.api
import statsmodels.formula.api
import patsy.contrasts
# Chunk 4
# lists, library_name.function_name notation
group = numpy.repeat(["A", "B", "C", "D"], repeats = 25)
# Chunk 5
# tuples
mean = (3, 4, 4, 3)
sigma = (1.5, 1.5, 1.5, 1.5)
n = (25, 25, 25, 25)
# Chunk 6
# Empty list
x = []
# Append list with random normal variables
for (a, b, c) in zip(mean, sigma, n):
x.append(numpy.random.normal(a, b, c))
# Join results
x = numpy.concatenate(x)
# Chunk 7
# y is corrletaed r = 0.75 with x, add random noise
y = x * 0.75 + numpy.random.normal(loc = 0.00, scale = 1.00, size = 100)
# curly brackets, colons
data1 = pandas.DataFrame({"y": y, "x": x, "group": group})
# Helmert contrasts
group_helmert = patsy.contrasts.Helmert().code_without_intercept(list(set(group)))
# 2 main effects and 1 interaction contrast
group_factorial = patsy.contrasts.ContrastMatrix([[-1, -1, 1], [-1, 1, -1], [1, -1, -1], [1, 1, 1]], ["Main Effect 1", "Main Effect 2", "Interaction"])
plotly.express.box(data1, x = "group", y = "y")
blogdown:::serve_site()
blogdown:::serve_site()
?rep
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
2.066164 + 0.154605 * qt(1 - 0.05 / 2, df = 49)
t.test(rnorm(50))
x <- rnorm(50)
mean(x) + (sd(x) / sqrt(length(x) - 1)) * qt(1 - 0.05 / 2, df = 49)
t.test(x)
mean(x) + (sd(x) / sqrt(length(x))) * qt(1 - 0.05 / 2, df = 49)
psych::describe(x)
sqrt(length(x)))
sqrt(length(x))
sd(x) / sqrt(length(x))
psych::describe(x)$se
?rnorm
?factor
